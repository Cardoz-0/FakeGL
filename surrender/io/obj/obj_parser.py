from dataclasses import dataclass
import re
from surrender.io.obj import (
    PointDescriptor,
    LineDescriptor,
    PolygonDescriptor,
    OBJ3DDescriptor,
)

from surrender.shapes import Point, Line, Polygon
from surrender.vector import Vector

line_regex = re.compile(r"[fgplov]((\s*)|(\s[\d|\s|\w|.]*))")


@dataclass
class Token:
    type: str
    args: str


class OBJParser:
    @classmethod
    def encode_shapes(cls, shapes):
        string = "# File generated by SurRender Developer Version \n\n"
        index = 1
        for shape in shapes:
            descriptor = cls._get_descriptor(shape)
            if descriptor is None:
                print(f"Warning: Falha ao encontrar o descritor de {shape}")
                continue
            string += descriptor.encode_shape(shape, index)
            num_points = len(shape.points())
            index += num_points
        return string

    @classmethod
    def parse_string(cls, string):
        tokens = cls._create_tokens(string)
        vertices = cls._read_vertices(tokens)

        name = ""
        current_group = []

        for token in tokens:
            if token.type == "o" or token.type == "g":
                if current_group:
                    yield cls._create_shape(name, current_group, vertices)
                    name = ""
                    current_group = []
                name = token.args
            else:
                current_group.append(token)

        if current_group:
            yield cls._create_shape(name, current_group, vertices)

    @classmethod
    def _create_shape(cls, name, tokens, vertices):
        if len(tokens) <= 0:
            return None

        if len(tokens) > 1:
            return OBJ3DDescriptor.parse_string(name, tokens, vertices)

        token = tokens[0]

        if token.type == "f":
            return PolygonDescriptor.parse_string(name, token.args, vertices)

        elif token.type == "p":
            return PointDescriptor.parse_string(name, token.args, vertices)

        elif token.type == "l":
            return LineDescriptor.parse_string(name, token.args, vertices)

    @classmethod
    def _get_descriptor(cls, shape):
        if isinstance(shape, Point):
            return PointDescriptor
        elif isinstance(shape, Line):
            return LineDescriptor
        elif isinstance(shape, Polygon):
            return PolygonDescriptor
        else:
            return None

    @classmethod
    def _create_tokens(cls, string):
        tokens = []
        for line in string.splitlines():
            if not line_regex.match(line):
                continue
            splitter = line.find(" ")
            if splitter == -1:
                token = Token(type=line.strip(), args="")
            else:
                token = Token(
                    type=line[:splitter].strip(), args=line[splitter:].strip()
                )
            tokens.append(token)
        return tokens

    @classmethod
    def _read_vertices(cls, tokens):
        vertices = []
        for token in tokens:
            if token.type == "v":
                x, y, z = (float(i) for i in token.args.split())
                v = Vector(x, y, z)
                vertices.append(v)
        return vertices
